\subsection{Controllers}
Assim que um pedido consegue ultrapassar todos os \textit{middlewares} sem ser impedido, este é então redirecionado para um \textit{controller}.

\subsubsection{Estruturação dos controllers}
Para evitar variação de código destes \textit{controllers} em termos de estrutura, foi então decidido desenhar uma estrutura de \textit{controller} e aplicar esta perante o demais código. Esta segue as seguintes etapas:
\begin{enumerate}
 \item Obter dados do pedido
 \item Validar se os dados obrigatórios são obtidos
 \item Validar o pedido perante o modelo de negócio
 \item Executar a lógica do pedido
 \item Formular a resposta e enviar
 \item Em caso de erro este deverá ser capturado e processado para enviar um erro para o utilizador
\end{enumerate}

 Esta estrutura será sempre aplicada pois foram utilizados \textit{snippets} de código que permitem criar um modelo de estrutura sendo apenas necessário escrever a palavra-chave e toda a estrutura é aplicar, pelo que é necessário de seguida efetuar as alterações perante o contexto.

\newpage

\subsubsection{Execução da lógica de negócio}
A execução da lógica de negócio passa por direcionar os dados para a ação correta, esta ação geralmente resulta numa operação de base de dados. Inicialmente foi desenvolvida toda a validação de código e todas as operações de base de dados diretamente na execução da lógica de negócio. Após uma revisão desta organização de código com o professor orientador, foi decidido separar estas funcionalidades, de onde surgiu a componente de validação de dados, a de operações de base de dados e a de lógica de negócio que implementa a componente de operações de base de dados. Sendo assim para evitar que estas operações sobre a base de dados estejam em conjunto com o direcionamento dos dados, foram criados modelos para cada tabela. Cada modelo contém um conjunto de operações sobre a tabela correspondente. Estas operações estão contidas sobre métodos que podem receber dados para executar na operação e devolver a resposta da mesma.

\subsubsection{Validação dos dados}
A validação dos dados é necessária para evitar erros a nível de servidor com dados em falta e também para aplicar as regras de negócio. Para realizar estas validações é em primeiro lugar verificado se todos os dados são recebidos, de seguida estes são enviados para um validador. O validador executa todas as verificações necessárias a nível de regras de negócio e na possibilidade de alguma regra não ser cumprida, é então atirado um erro.

\subsubsection{Formulação da resposta}
Assim como mencionado anteriormente o bem mais importante numa boa comunicação é a utilização da mesma linguagem, sendo assim a resposta do servidor deverá  utilizar a linguagem indicada pelo utilizador. De forma a realizar esta tradução foi utilizado o mesmo conceito que é utilizado para a tradução de aplicações android onde nestas é criado um ficheiro que contém um conjunto de chaves e a cada chave corresponde um texto, para cada tradução estas chaves têm de existir de forma a ser possível obter o texto correto para cada chave. Sendo assim foi utilizado um ficheiro json contento as chaves das linguagens suportadas, a cada linguagem corresponde um conjunto de outras chaves que contém todas as traduções necessárias, utilizando neste caso numeração, em vez de palavras. Esta abordagem permite que de forma fácil futuramente seja possível adicionar outras linguagens ao servidor.

% //TODO mostrar exemplo

Para dar suporte a este ficheiro foi criada uma operação que recebe a chave desejada e a linguagem desejada, devolvendo o texto correspondente, sendo assim na Formulação da resposta esta operação é executada indicando a chave da resposta a enviar e a linguagem desejada obtendo o texto traduzido, sendo então este devolvido para o utilizador.

\newpage

\subsubsection{Processamento de erros}
Visto que não é de interesse enviar para o utilizador erros do próprio servidor, foi então decidido controlar estes, para isso foi criado um erro customizado, tendo este por base o erro da própria linguagem. Este erro recebe por parâmetro o código da tradução da mensagem de erro. Esta abordagem permite também evitar que sempre que um erro é lançado o sistema pare. Mesmo com esta abordagem acontece que sempre que um erro é lançado por base de dados, erro de código ou de biblioteca, o erro original é chamado, pelo que foi decidido que sempre que é detetado um erro que não é do tipo do erro customizado, então será devolvido um erro com mensagem de erro de servidor evitando que dados sensíveis e desnecessários para o utilizador sejam devolvidos.