\chapter{Implementação}

\input{sections/chap5/webscraper.tex}

\newpage

\section{Serviços Backend}

De forma a realizar a integração entre a aplicação \emph{frontend} e os dados, foi necessário desenvolver
uma API para dar suporte a todos os serviços necessários para a aplicação.
API sigla para \emph{Application Programming Interface} disponibiliza um conjunto de funções e
dados que facilita as interações entre aplicações e permite que troquem informação ~\cite{rest_cookbook}.
Esta ferramenta apesar de ser desenvolvida para trabalhar em conjunto com outros programas, ela são
em sua grande maioria desenvolvidas para serem entendidas e utilizadas por outros programadores no
desenvolvimento dos seus programas ~\cite{api_design}.

\subsection{Serviços REST Full}
Explicar o que é

\subsection{Organização do projeto}
Antes de iniciar a implementação, foi definido qual a estrutura de projeto a seguir, pelo que a esoclhida
foi MVC devido a ser a mais comum e estabelecida. Sendo assim a organização do projeto segue a seguinte estrutura:
\begin{figure}[htb]
  \centering
  \includegraphics[width=0.2\textwidth]{images/implementacao/api/project_organization.png}
  \caption{Exemplo de página de produto incomum}
  \label{fig:61}
\end{figure}

\begin{itemize}
  \item \textbf{docs} - Documentação gerada;
  \item \textbf{src} - Base de todo o projeto;
  \item \textbf{config} - Ficheiros de configuração do projeto;
  \item \textbf{controllers} - Controladores para cada pedido;
  \item \textbf{helpers} - Ficheiros com funções gerais utilizadas regularmente;
  \item \textbf{middlewares} - Ficheiros com os middlewares da api;
  \item \textbf{models} - Classes criadas para representação de base de dados e para as entidades de resposta;
  \item \textbf{routes} - Rotas existentes;
  \item \textbf{services} - Serviços para cada pedido;
  \item \textbf{templates} - Templates de email a serem enviados;
  \item \textbf{tests} - Testes de código realizados;
  \item \textbf{validations} - Validações a realizar a nível de modelo de negócio e validação de dados;
  \item \textbf{app} - Ficheiro de início do projeto;
\end{itemize}

\subsection{Definição de rotas base}
Após a definição da estrutura do projeto foi então definido as rotas base a existir, estas são rotas
que se referem a cada tipo de utilizador. Para melhor organização destas rotas e aplicação de regras foram definidos 3 routers,
user para utilizadores se sessão, professional para técnicos e company para empresas. De forma a definir para o projeto qual o router a utilizar
em cada pedido foi então definido que:
\begin{itemize}
  \item \textbf{http://baseurl:port/professional} - Encaminhar para router de técnicos;
  \item \textbf{http://baseurl:port/company} - Encaminhar para router de empresas;
  \item \textbf{Restantes} - Encaminhar para router de user;
\end{itemize}

\subsection{Middlewares} 
Um middleware comporta-se como uma ligação entre porções de código, sendo possível este também executar código.

\subsubsection{Linguagem}
O bem mais essencial em uma boa comunicação entre duas partes é a utilização da mesma linguagem, sendo assim foi necessário perceber
qual a linguagem a utilizar quando se responde a um pedido. Para este fim foi então desenvolvido um middleware,
o objetivo deste é verificar se existe a chave language no cabeçalho do pedido, caso esta exista é então obtido a linguagem e guargada
nas variáveis locais do pedido. Em caso de esta tag não existir, foi então decido que a aplicação responderá em português por omissão,
este valor poderá ser futuramente alterado de forma simples.

\subsubsection{Autenticação}
De forma a assegurar a autenticação dos utilizadores que necessitam desta foi então decidido implementar JsonWebToken,
este tipo de autenticação baseia-se em a utilização de tokens com tempo de expiração, sendo que enquando o token estiver válido,
o utilizador poderá realizar pedidos e assim que este token expirar este terá de se autenticar novamente para obter um novo token.
A utilização de tokens permite também assegurar que os pedidos são realizados com tokens gerados pela api através de utilização de uma chave
de assinatura de token, impedindo assim a utilização de tokens gerados por utilizadores.
\begin{figure}[htb]
  \centering
  \includegraphics[width=0.5\textwidth]{images/implementacao/api/jwt_session.png}
  \caption{Exemplo de página de produto incomum}
  \label{fig:62}
\end{figure}

A grande valia da utilização a técnica de autenticação mencionada anteriormente é a segurança desta, mas este nivel de segurança
leva a que as aplicações que não necessitam de um nivel de segurança muito alto se tornem impráticas. Isto acontece porque estes 
tokens têm geralmente uma duração muito curta como por exemplo 15 minutos, e sempre que um token de sessão expira o utilizador 
teria de realizar novamente o login.

A solução deste problema sem a perda de segurança significativa veio pelo meio da utilização de tokens de duração maior em conjunto 
com os tokens de duração curta, sendo que enquanto o token de grande duração estiver válido, novos tokens de curta duração são gerados 
para o utilizador nunca perdendo assim a sua sessão. Estes tokens de grande duração tem por nome tokens de refresh e os tokens de curta 
duração têm por nome tokens de sessão. Sempre que o utilizador termina a sua sessão o token de refresh deverá ser apagado.

Sempre que um utilizador realiza um pedido o seu token de sessão deverá ser validado, caso este seja válido, o seu token de refresh deverá 
também ser validado e apenas após isto o utilizador estará autenticado. Caso o token de sessão ou de refresh esteja expirado, este continuará
a estar sem autorização para realizar o pedido, mas poderá pedir um novo token de sessão enquanto o seu token de refresh estiver válido, 
isto acontece sem realizar novamente o login e sem o utilizador perceber.